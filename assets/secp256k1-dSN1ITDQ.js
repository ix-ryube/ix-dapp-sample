import{H as ne,c as Ut,e as mt,t as re,o as Be,w as ve,r as G,h as Se,b as Ae,a as Ie,d as oe}from"./index-Wvb-j8Jn.js";function _e(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const o=BigInt(32),s=BigInt(4294967295),f=Number(e>>o&s),i=Number(e&s),c=r?4:0,a=r?0:4;t.setUint32(n+c,f,r),t.setUint32(n+a,i,r)}class Oe extends ne{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=Ut(this.buffer)}update(n){mt(this);const{view:e,buffer:r,blockLen:o}=this;n=re(n);const s=n.length;for(let f=0;f<s;){const i=Math.min(o-this.pos,s-f);if(i===o){const c=Ut(n);for(;o<=s-f;f+=o)this.process(c,f);continue}r.set(n.subarray(f,f+i),this.pos),this.pos+=i,f+=i,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){mt(this),Be(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:s}=this;let{pos:f}=this;e[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>o-f&&(this.process(r,0),f=0);for(let u=f;u<o;u++)e[u]=0;_e(r,o-8,BigInt(this.length*8),s),this.process(r,0);const i=Ut(n),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4,h=this.get();if(a>h.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)i.setUint32(4*u,h[u],s)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:s,destroyed:f,pos:i}=this;return n.length=o,n.pos=i,n.finished=s,n.destroyed=f,o%e&&n.buffer.set(r),n}}const qe=(t,n,e)=>t&n^~t&e,Ne=(t,n,e)=>t&n^t&e^n&e,Ue=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),F=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),tt=new Uint32Array(64);class Te extends Oe{constructor(){super(64,32,8,!1),this.A=F[0]|0,this.B=F[1]|0,this.C=F[2]|0,this.D=F[3]|0,this.E=F[4]|0,this.F=F[5]|0,this.G=F[6]|0,this.H=F[7]|0}get(){const{A:n,B:e,C:r,D:o,E:s,F:f,G:i,H:c}=this;return[n,e,r,o,s,f,i,c]}set(n,e,r,o,s,f,i,c){this.A=n|0,this.B=e|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=f|0,this.G=i|0,this.H=c|0}process(n,e){for(let u=0;u<16;u++,e+=4)tt[u]=n.getUint32(e,!1);for(let u=16;u<64;u++){const v=tt[u-15],E=tt[u-2],y=G(v,7)^G(v,18)^v>>>3,l=G(E,17)^G(E,19)^E>>>10;tt[u]=l+tt[u-7]+y+tt[u-16]|0}let{A:r,B:o,C:s,D:f,E:i,F:c,G:a,H:h}=this;for(let u=0;u<64;u++){const v=G(i,6)^G(i,11)^G(i,25),E=h+v+qe(i,c,a)+Ue[u]+tt[u]|0,l=(G(r,2)^G(r,13)^G(r,22))+Ne(r,o,s)|0;h=a,a=c,c=i,i=f+E|0,f=s,s=o,o=r,r=E+l|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,f=f+this.D|0,i=i+this.E|0,c=c+this.F|0,a=a+this.G|0,h=h+this.H|0,this.set(r,o,s,f,i,c,a,h)}roundClean(){tt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const pt=ve(()=>new Te);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const se=BigInt(0),St=BigInt(1),He=BigInt(2),At=t=>t instanceof Uint8Array,Le=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function dt(t){if(!At(t))throw new Error("Uint8Array expected");let n="";for(let e=0;e<t.length;e++)n+=Le[t[e]];return n}function ie(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function Zt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function ht(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const e=new Uint8Array(n/2);for(let r=0;r<e.length;r++){const o=r*2,s=t.slice(o,o+2),f=Number.parseInt(s,16);if(Number.isNaN(f)||f<0)throw new Error("Invalid byte sequence");e[r]=f}return e}function Z(t){return Zt(dt(t))}function Vt(t){if(!At(t))throw new Error("Uint8Array expected");return Zt(dt(Uint8Array.from(t).reverse()))}function rt(t,n){return ht(t.toString(16).padStart(n*2,"0"))}function Pt(t,n){return rt(t,n).reverse()}function Re(t){return ht(ie(t))}function $(t,n,e){let r;if(typeof n=="string")try{r=ht(n)}catch(s){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${s}`)}else if(At(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(`${t} expected ${e} bytes, got ${o}`);return r}function K(...t){const n=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let e=0;return t.forEach(r=>{if(!At(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}function Ce(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function It(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function $e(t){let n;for(n=0;t>se;t>>=St,n+=1);return n}function ke(t,n){return t>>BigInt(n)&St}const Ze=(t,n,e)=>t|(e?St:se)<<BigInt(n),zt=t=>(He<<BigInt(t-1))-St,Tt=t=>new Uint8Array(t),Wt=t=>Uint8Array.from(t);function ce(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Tt(t),o=Tt(t),s=0;const f=()=>{r.fill(1),o.fill(0),s=0},i=(...u)=>e(o,r,...u),c=(u=Tt())=>{o=i(Wt([0]),u),r=i(),u.length!==0&&(o=i(Wt([1]),u),r=i())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const v=[];for(;u<n;){r=i();const E=r.slice();v.push(E),u+=r.length}return K(...v)};return(u,v)=>{f(),c(u);let E;for(;!(E=v(a()));)c();return f(),E}}const Ve={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function gt(t,n,e={}){const r=(o,s,f)=>{const i=Ve[s];if(typeof i!="function")throw new Error(`Invalid validator "${s}", expected function`);const c=t[o];if(!(f&&c===void 0)&&!i(c,t))throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${s}`)};for(const[o,s]of Object.entries(n))r(o,s,!1);for(const[o,s]of Object.entries(e))r(o,s,!0);return t}const Pe=Object.freeze(Object.defineProperty({__proto__:null,bitGet:ke,bitLen:$e,bitMask:zt,bitSet:Ze,bytesToHex:dt,bytesToNumberBE:Z,bytesToNumberLE:Vt,concatBytes:K,createHmacDrbg:ce,ensureBytes:$,equalBytes:Ce,hexToBytes:ht,hexToNumber:Zt,numberToBytesBE:rt,numberToBytesLE:Pt,numberToHexUnpadded:ie,numberToVarBytesBE:Re,utf8ToBytes:It,validateObject:gt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C=BigInt(0),H=BigInt(1),it=BigInt(2),ze=BigInt(3),Rt=BigInt(4),Xt=BigInt(5),Qt=BigInt(8);BigInt(9);BigInt(16);function R(t,n){const e=t%n;return e>=C?e:n+e}function je(t,n,e){if(e<=C||n<C)throw new Error("Expected power/modulo > 0");if(e===H)return C;let r=H;for(;n>C;)n&H&&(r=r*t%e),t=t*t%e,n>>=H;return r}function D(t,n,e){let r=t;for(;n-- >C;)r*=r,r%=e;return r}function Ct(t,n){if(t===C||n<=C)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=R(t,n),r=n,o=C,s=H;for(;e!==C;){const i=r/e,c=r%e,a=o-s*i;r=e,e=c,o=s,s=a}if(r!==H)throw new Error("invert: does not exist");return R(o,n)}function Ke(t){const n=(t-H)/it;let e,r,o;for(e=t-H,r=0;e%it===C;e/=it,r++);for(o=it;o<t&&je(o,n,t)!==t-H;o++);if(r===1){const f=(t+H)/Rt;return function(c,a){const h=c.pow(a,f);if(!c.eql(c.sqr(h),a))throw new Error("Cannot find square root");return h}}const s=(e+H)/it;return function(i,c){if(i.pow(c,n)===i.neg(i.ONE))throw new Error("Cannot find square root");let a=r,h=i.pow(i.mul(i.ONE,o),e),u=i.pow(c,s),v=i.pow(c,e);for(;!i.eql(v,i.ONE);){if(i.eql(v,i.ZERO))return i.ZERO;let E=1;for(let l=i.sqr(v);E<a&&!i.eql(l,i.ONE);E++)l=i.sqr(l);const y=i.pow(h,H<<BigInt(a-E-1));h=i.sqr(y),u=i.mul(u,y),v=i.mul(v,h),a=E}return u}}function De(t){if(t%Rt===ze){const n=(t+H)/Rt;return function(r,o){const s=r.pow(o,n);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%Qt===Xt){const n=(t-Xt)/Qt;return function(r,o){const s=r.mul(o,it),f=r.pow(s,n),i=r.mul(o,f),c=r.mul(r.mul(i,it),f),a=r.mul(i,r.sub(c,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return Ke(t)}const Me=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function fe(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Me.reduce((r,o)=>(r[o]="function",r),n);return gt(t,e)}function Ye(t,n,e){if(e<C)throw new Error("Expected power > 0");if(e===C)return t.ONE;if(e===H)return n;let r=t.ONE,o=n;for(;e>C;)e&H&&(r=t.mul(r,o)),o=t.sqr(o),e>>=H;return r}function Ge(t,n){const e=new Array(n.length),r=n.reduce((s,f,i)=>t.is0(f)?s:(e[i]=s,t.mul(s,f)),t.ONE),o=t.inv(r);return n.reduceRight((s,f,i)=>t.is0(f)?s:(e[i]=t.mul(s,e[i]),t.mul(s,f)),o),e}function ae(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function We(t,n,e=!1,r={}){if(t<=C)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:s}=ae(t,n);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=De(t),i=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:zt(o),ZERO:C,ONE:H,create:c=>R(c,t),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return C<=c&&c<t},is0:c=>c===C,isOdd:c=>(c&H)===H,neg:c=>R(-c,t),eql:(c,a)=>c===a,sqr:c=>R(c*c,t),add:(c,a)=>R(c+a,t),sub:(c,a)=>R(c-a,t),mul:(c,a)=>R(c*a,t),pow:(c,a)=>Ye(i,c,a),div:(c,a)=>R(c*Ct(a,t),t),sqrN:c=>c*c,addN:(c,a)=>c+a,subN:(c,a)=>c-a,mulN:(c,a)=>c*a,inv:c=>Ct(c,t),sqrt:r.sqrt||(c=>f(i,c)),invertBatch:c=>Ge(i,c),cmov:(c,a,h)=>h?a:c,toBytes:c=>e?Pt(c,s):rt(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return e?Vt(c):Z(c)}});return Object.freeze(i)}function ue(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function le(t){const n=ue(t);return n+Math.ceil(n/2)}function Xe(t,n,e=!1){const r=t.length,o=ue(n),s=le(n);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const f=e?Z(t):Vt(t),i=R(f,n-H)+H;return e?Pt(i,o):rt(i,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Qe=BigInt(0),Ht=BigInt(1);function Je(t,n){const e=(o,s)=>{const f=s.negate();return o?f:s},r=o=>{const s=Math.ceil(n/o)+1,f=2**(o-1);return{windows:s,windowSize:f}};return{constTimeNegate:e,unsafeLadder(o,s){let f=t.ZERO,i=o;for(;s>Qe;)s&Ht&&(f=f.add(i)),i=i.double(),s>>=Ht;return f},precomputeWindow(o,s){const{windows:f,windowSize:i}=r(s),c=[];let a=o,h=a;for(let u=0;u<f;u++){h=a,c.push(h);for(let v=1;v<i;v++)h=h.add(a),c.push(h);a=h.double()}return c},wNAF(o,s,f){const{windows:i,windowSize:c}=r(o);let a=t.ZERO,h=t.BASE;const u=BigInt(2**o-1),v=2**o,E=BigInt(o);for(let y=0;y<i;y++){const l=y*c;let g=Number(f&u);f>>=E,g>c&&(g-=v,f+=Ht);const d=l,b=l+Math.abs(g)-1,p=y%2!==0,S=g<0;g===0?h=h.add(e(p,s[d])):a=a.add(e(S,s[b]))}return{p:a,f:h}},wNAFCached(o,s,f,i){const c=o._WINDOW_SIZE||1;let a=s.get(o);return a||(a=this.precomputeWindow(o,c),c!==1&&s.set(o,i(a))),this.wNAF(c,a,f)}}}function de(t){return fe(t.Fp),gt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ae(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Fe(t){const n=de(t);gt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:tn,hexToBytes:en}=Pe,ct={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){const{Err:n}=ct;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:tn(r),l:t.subarray(e+2)}},toSig(t){const{Err:n}=ct,e=typeof t=="string"?en(t):t;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:o,l:s}=ct._parseInt(e.subarray(2)),{d:f,l:i}=ct._parseInt(s);if(i.length)throw new n("Invalid signature: left bytes after parsing");return{r:o,s:f}},hexFromSig(t){const n=a=>Number.parseInt(a[0],16)&8?"00"+a:a,e=a=>{const h=a.toString(16);return h.length&1?`0${h}`:h},r=n(e(t.s)),o=n(e(t.r)),s=r.length/2,f=o.length/2,i=e(s),c=e(f);return`30${e(f+s+4)}02${c}${o}02${i}${r}`}},Y=BigInt(0),T=BigInt(1),et=BigInt(2),xt=BigInt(3),Jt=BigInt(4);function nn(t){const n=Fe(t),{Fp:e}=n,r=n.toBytes||((y,l,g)=>{const d=l.toAffine();return K(Uint8Array.from([4]),e.toBytes(d.x),e.toBytes(d.y))}),o=n.fromBytes||(y=>{const l=y.subarray(1),g=e.fromBytes(l.subarray(0,e.BYTES)),d=e.fromBytes(l.subarray(e.BYTES,2*e.BYTES));return{x:g,y:d}});function s(y){const{a:l,b:g}=n,d=e.sqr(y),b=e.mul(d,y);return e.add(e.add(b,e.mul(y,l)),g)}if(!e.eql(e.sqr(n.Gy),s(n.Gx)))throw new Error("bad generator point: equation left != right");function f(y){return typeof y=="bigint"&&Y<y&&y<n.n}function i(y){if(!f(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(y){const{allowedPrivateKeyLengths:l,nByteLength:g,wrapPrivateKey:d,n:b}=n;if(l&&typeof y!="bigint"){if(y instanceof Uint8Array&&(y=dt(y)),typeof y!="string"||!l.includes(y.length))throw new Error("Invalid key");y=y.padStart(g*2,"0")}let p;try{p=typeof y=="bigint"?y:Z($("private key",y,g))}catch{throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof y}`)}return d&&(p=R(p,b)),i(p),p}const a=new Map;function h(y){if(!(y instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,g,d){if(this.px=l,this.py=g,this.pz=d,l==null||!e.isValid(l))throw new Error("x required");if(g==null||!e.isValid(g))throw new Error("y required");if(d==null||!e.isValid(d))throw new Error("z required")}static fromAffine(l){const{x:g,y:d}=l||{};if(!l||!e.isValid(g)||!e.isValid(d))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");const b=p=>e.eql(p,e.ZERO);return b(g)&&b(d)?u.ZERO:new u(g,d,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const g=e.invertBatch(l.map(d=>d.pz));return l.map((d,b)=>d.toAffine(g[b])).map(u.fromAffine)}static fromHex(l){const g=u.fromAffine(o($("pointHex",l)));return g.assertValidity(),g}static fromPrivateKey(l){return u.BASE.multiply(c(l))}_setWindowSize(l){this._WINDOW_SIZE=l,a.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:l,y:g}=this.toAffine();if(!e.isValid(l)||!e.isValid(g))throw new Error("bad point: x or y not FE");const d=e.sqr(g),b=s(l);if(!e.eql(d,b))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(e.isOdd)return!e.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){h(l);const{px:g,py:d,pz:b}=this,{px:p,py:S,pz:I}=l,x=e.eql(e.mul(g,I),e.mul(p,b)),B=e.eql(e.mul(d,I),e.mul(S,b));return x&&B}negate(){return new u(this.px,e.neg(this.py),this.pz)}double(){const{a:l,b:g}=n,d=e.mul(g,xt),{px:b,py:p,pz:S}=this;let I=e.ZERO,x=e.ZERO,B=e.ZERO,A=e.mul(b,b),k=e.mul(p,p),U=e.mul(S,S),O=e.mul(b,p);return O=e.add(O,O),B=e.mul(b,S),B=e.add(B,B),I=e.mul(l,B),x=e.mul(d,U),x=e.add(I,x),I=e.sub(k,x),x=e.add(k,x),x=e.mul(I,x),I=e.mul(O,I),B=e.mul(d,B),U=e.mul(l,U),O=e.sub(A,U),O=e.mul(l,O),O=e.add(O,B),B=e.add(A,A),A=e.add(B,A),A=e.add(A,U),A=e.mul(A,O),x=e.add(x,A),U=e.mul(p,S),U=e.add(U,U),A=e.mul(U,O),I=e.sub(I,A),B=e.mul(U,k),B=e.add(B,B),B=e.add(B,B),new u(I,x,B)}add(l){h(l);const{px:g,py:d,pz:b}=this,{px:p,py:S,pz:I}=l;let x=e.ZERO,B=e.ZERO,A=e.ZERO;const k=n.a,U=e.mul(n.b,xt);let O=e.mul(g,p),V=e.mul(d,S),P=e.mul(b,I),W=e.add(g,d),w=e.add(p,S);W=e.mul(W,w),w=e.add(O,V),W=e.sub(W,w),w=e.add(g,b);let m=e.add(p,I);return w=e.mul(w,m),m=e.add(O,P),w=e.sub(w,m),m=e.add(d,b),x=e.add(S,I),m=e.mul(m,x),x=e.add(V,P),m=e.sub(m,x),A=e.mul(k,w),x=e.mul(U,P),A=e.add(x,A),x=e.sub(V,A),A=e.add(V,A),B=e.mul(x,A),V=e.add(O,O),V=e.add(V,O),P=e.mul(k,P),w=e.mul(U,w),V=e.add(V,P),P=e.sub(O,P),P=e.mul(k,P),w=e.add(w,P),O=e.mul(V,w),B=e.add(B,O),O=e.mul(m,w),x=e.mul(W,x),x=e.sub(x,O),O=e.mul(W,V),A=e.mul(m,A),A=e.add(A,O),new u(x,B,A)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return E.wNAFCached(this,a,l,g=>{const d=e.invertBatch(g.map(b=>b.pz));return g.map((b,p)=>b.toAffine(d[p])).map(u.fromAffine)})}multiplyUnsafe(l){const g=u.ZERO;if(l===Y)return g;if(i(l),l===T)return this;const{endo:d}=n;if(!d)return E.unsafeLadder(this,l);let{k1neg:b,k1:p,k2neg:S,k2:I}=d.splitScalar(l),x=g,B=g,A=this;for(;p>Y||I>Y;)p&T&&(x=x.add(A)),I&T&&(B=B.add(A)),A=A.double(),p>>=T,I>>=T;return b&&(x=x.negate()),S&&(B=B.negate()),B=new u(e.mul(B.px,d.beta),B.py,B.pz),x.add(B)}multiply(l){i(l);let g=l,d,b;const{endo:p}=n;if(p){const{k1neg:S,k1:I,k2neg:x,k2:B}=p.splitScalar(g);let{p:A,f:k}=this.wNAF(I),{p:U,f:O}=this.wNAF(B);A=E.constTimeNegate(S,A),U=E.constTimeNegate(x,U),U=new u(e.mul(U.px,p.beta),U.py,U.pz),d=A.add(U),b=k.add(O)}else{const{p:S,f:I}=this.wNAF(g);d=S,b=I}return u.normalizeZ([d,b])[0]}multiplyAndAddUnsafe(l,g,d){const b=u.BASE,p=(I,x)=>x===Y||x===T||!I.equals(b)?I.multiplyUnsafe(x):I.multiply(x),S=p(this,g).add(p(l,d));return S.is0()?void 0:S}toAffine(l){const{px:g,py:d,pz:b}=this,p=this.is0();l==null&&(l=p?e.ONE:e.inv(b));const S=e.mul(g,l),I=e.mul(d,l),x=e.mul(b,l);if(p)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:S,y:I}}isTorsionFree(){const{h:l,isTorsionFree:g}=n;if(l===T)return!0;if(g)return g(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:g}=n;return l===T?this:g?g(u,this):this.multiplyUnsafe(n.h)}toRawBytes(l=!0){return this.assertValidity(),r(u,this,l)}toHex(l=!0){return dt(this.toRawBytes(l))}}u.BASE=new u(n.Gx,n.Gy,e.ONE),u.ZERO=new u(e.ZERO,e.ONE,e.ZERO);const v=n.nBitLength,E=Je(u,n.endo?Math.ceil(v/2):v);return{CURVE:n,ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:f}}function rn(t){const n=de(t);return gt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function on(t){const n=rn(t),{Fp:e,n:r}=n,o=e.BYTES+1,s=2*e.BYTES+1;function f(w){return Y<w&&w<e.ORDER}function i(w){return R(w,r)}function c(w){return Ct(w,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:h,weierstrassEquation:u,isWithinCurveOrder:v}=nn({...n,toBytes(w,m,_){const N=m.toAffine(),q=e.toBytes(N.x),L=K;return _?L(Uint8Array.from([m.hasEvenY()?2:3]),q):L(Uint8Array.from([4]),q,e.toBytes(N.y))},fromBytes(w){const m=w.length,_=w[0],N=w.subarray(1);if(m===o&&(_===2||_===3)){const q=Z(N);if(!f(q))throw new Error("Point is not on curve");const L=u(q);let z=e.sqrt(L);const j=(z&T)===T;return(_&1)===1!==j&&(z=e.neg(z)),{x:q,y:z}}else if(m===s&&_===4){const q=e.fromBytes(N.subarray(0,e.BYTES)),L=e.fromBytes(N.subarray(e.BYTES,2*e.BYTES));return{x:q,y:L}}else throw new Error(`Point of length ${m} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),E=w=>dt(rt(w,n.nByteLength));function y(w){const m=r>>T;return w>m}function l(w){return y(w)?i(-w):w}const g=(w,m,_)=>Z(w.slice(m,_));class d{constructor(m,_,N){this.r=m,this.s=_,this.recovery=N,this.assertValidity()}static fromCompact(m){const _=n.nByteLength;return m=$("compactSignature",m,_*2),new d(g(m,0,_),g(m,_,2*_))}static fromDER(m){const{r:_,s:N}=ct.toSig($("DER",m));return new d(_,N)}assertValidity(){if(!v(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!v(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(m){return new d(this.r,this.s,m)}recoverPublicKey(m){const{r:_,s:N,recovery:q}=this,L=B($("msgHash",m));if(q==null||![0,1,2,3].includes(q))throw new Error("recovery id invalid");const z=q===2||q===3?_+n.n:_;if(z>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=q&1?"03":"02",X=a.fromHex(j+E(z)),Q=c(z),ft=i(-L*Q),wt=i(N*Q),J=a.BASE.multiplyAndAddUnsafe(X,ft,wt);if(!J)throw new Error("point at infinify");return J.assertValidity(),J}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const b={isValidPrivateKey(w){try{return h(w),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const w=le(n.n);return Xe(n.randomBytes(w),n.n)},precompute(w=8,m=a.BASE){return m._setWindowSize(w),m.multiply(BigInt(3)),m}};function p(w,m=!0){return a.fromPrivateKey(w).toRawBytes(m)}function S(w){const m=w instanceof Uint8Array,_=typeof w=="string",N=(m||_)&&w.length;return m?N===o||N===s:_?N===2*o||N===2*s:w instanceof a}function I(w,m,_=!0){if(S(w))throw new Error("first arg must be private key");if(!S(m))throw new Error("second arg must be public key");return a.fromHex(m).multiply(h(w)).toRawBytes(_)}const x=n.bits2int||function(w){const m=Z(w),_=w.length*8-n.nBitLength;return _>0?m>>BigInt(_):m},B=n.bits2int_modN||function(w){return i(x(w))},A=zt(n.nBitLength);function k(w){if(typeof w!="bigint")throw new Error("bigint expected");if(!(Y<=w&&w<A))throw new Error(`bigint expected < 2^${n.nBitLength}`);return rt(w,n.nByteLength)}function U(w,m,_=O){if(["recovered","canonical"].some(st=>st in _))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:q}=n;let{lowS:L,prehash:z,extraEntropy:j}=_;L==null&&(L=!0),w=$("msgHash",w),z&&(w=$("prehashed msgHash",N(w)));const X=B(w),Q=h(m),ft=[k(Q),k(X)];if(j!=null){const st=j===!0?q(e.BYTES):j;ft.push($("extraEntropy",st))}const wt=K(...ft),J=X;function Nt(st){const at=x(st);if(!v(at))return;const Mt=c(at),ut=a.BASE.multiply(at).toAffine(),M=i(ut.x);if(M===Y)return;const lt=i(Mt*i(J+M*Q));if(lt===Y)return;let Yt=(ut.x===M?0:2)|Number(ut.y&T),Gt=lt;return L&&y(lt)&&(Gt=l(lt),Yt^=1),new d(M,Gt,Yt)}return{seed:wt,k2sig:Nt}}const O={lowS:n.lowS,prehash:!1},V={lowS:n.lowS,prehash:!1};function P(w,m,_=O){const{seed:N,k2sig:q}=U(w,m,_),L=n;return ce(L.hash.outputLen,L.nByteLength,L.hmac)(N,q)}a.BASE._setWindowSize(8);function W(w,m,_,N=V){var ut;const q=w;if(m=$("msgHash",m),_=$("publicKey",_),"strict"in N)throw new Error("options.strict was renamed to lowS");const{lowS:L,prehash:z}=N;let j,X;try{if(typeof q=="string"||q instanceof Uint8Array)try{j=d.fromDER(q)}catch(M){if(!(M instanceof ct.Err))throw M;j=d.fromCompact(q)}else if(typeof q=="object"&&typeof q.r=="bigint"&&typeof q.s=="bigint"){const{r:M,s:lt}=q;j=new d(M,lt)}else throw new Error("PARSE");X=a.fromHex(_)}catch(M){if(M.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(L&&j.hasHighS())return!1;z&&(m=n.hash(m));const{r:Q,s:ft}=j,wt=B(m),J=c(ft),Nt=i(wt*J),st=i(Q*J),at=(ut=a.BASE.multiplyAndAddUnsafe(X,Nt,st))==null?void 0:ut.toAffine();return at?i(at.x)===Q:!1}return{CURVE:n,getPublicKey:p,getSharedSecret:I,sign:P,verify:W,ProjectivePoint:a,Signature:d,utils:b}}function sn(t,n){const e=t.ORDER;let r=Y;for(let y=e-T;y%et===Y;y/=et)r+=T;const o=r,s=et<<o-T-T,f=s*et,i=(e-T)/f,c=(i-T)/et,a=f-T,h=s,u=t.pow(n,i),v=t.pow(n,(i+T)/et);let E=(y,l)=>{let g=u,d=t.pow(l,a),b=t.sqr(d);b=t.mul(b,l);let p=t.mul(y,b);p=t.pow(p,c),p=t.mul(p,d),d=t.mul(p,l),b=t.mul(p,y);let S=t.mul(b,d);p=t.pow(S,h);let I=t.eql(p,t.ONE);d=t.mul(b,v),p=t.mul(S,g),b=t.cmov(d,b,I),S=t.cmov(p,S,I);for(let x=o;x>T;x--){let B=x-et;B=et<<B-T;let A=t.pow(S,B);const k=t.eql(A,t.ONE);d=t.mul(b,g),g=t.mul(g,g),A=t.mul(S,g),b=t.cmov(d,b,k),S=t.cmov(A,S,k)}return{isValid:I,value:b}};if(t.ORDER%Jt===xt){const y=(t.ORDER-xt)/Jt,l=t.sqrt(t.neg(n));E=(g,d)=>{let b=t.sqr(d);const p=t.mul(g,d);b=t.mul(b,p);let S=t.pow(b,y);S=t.mul(S,p);const I=t.mul(S,l),x=t.mul(t.sqr(S),d),B=t.eql(x,g);let A=t.cmov(I,S,B);return{isValid:B,value:A}}}return E}function cn(t,n){if(fe(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=sn(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,f,i,c,a,h,u;o=t.sqr(r),o=t.mul(o,n.Z),s=t.sqr(o),s=t.add(s,o),f=t.add(s,t.ONE),f=t.mul(f,n.B),i=t.cmov(n.Z,t.neg(s),!t.eql(s,t.ZERO)),i=t.mul(i,n.A),s=t.sqr(f),a=t.sqr(i),c=t.mul(a,n.A),s=t.add(s,c),s=t.mul(s,f),a=t.mul(a,i),c=t.mul(a,n.B),s=t.add(s,c),h=t.mul(o,f);const{isValid:v,value:E}=e(s,a);u=t.mul(o,r),u=t.mul(u,E),h=t.cmov(h,f,v),u=t.cmov(u,E,v);const y=t.isOdd(r)===t.isOdd(u);return u=t.cmov(t.neg(u),u,y),h=t.div(h,i),{x:h,y:u}}}function fn(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return It(t);throw new Error("DST must be Uint8Array or string")}const an=Z;function nt(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function un(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function bt(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function jt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function ln(t,n,e,r){bt(t),bt(n),jt(e),n.length>255&&(n=r(K(It("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:s}=r,f=Math.ceil(e/o);if(f>255)throw new Error("Invalid xmd length");const i=K(n,nt(n.length,1)),c=nt(0,s),a=nt(e,2),h=new Array(f),u=r(K(c,t,a,nt(0,1),i));h[0]=r(K(u,nt(1,1),i));for(let E=1;E<=f;E++){const y=[un(u,h[E-1]),nt(E+1,1),i];h[E]=r(K(...y))}return K(...h).slice(0,e)}function dn(t,n,e,r,o){if(bt(t),bt(n),jt(e),n.length>255){const s=Math.ceil(2*r/8);n=o.create({dkLen:s}).update(It("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(nt(e,2)).update(n).update(nt(n.length,1)).digest()}function Ft(t,n,e){gt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:f,expand:i,DST:c}=e;bt(t),jt(n);const a=fn(c),h=r.toString(2).length,u=Math.ceil((h+o)/8),v=n*s*u;let E;if(i==="xmd")E=ln(t,a,v,f);else if(i==="xof")E=dn(t,a,v,o,f);else if(i==="_internal_pass")E=t;else throw new Error('expand must be "xmd" or "xof"');const y=new Array(n);for(let l=0;l<n;l++){const g=new Array(s);for(let d=0;d<s;d++){const b=u*(d+l*s),p=E.subarray(b,b+u);g[d]=R(an(p),r)}y[l]=g}return y}function hn(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,o)=>{const[s,f,i,c]=e.map(a=>a.reduce((h,u)=>t.add(t.mul(h,r),u)));return r=t.div(s,f),o=t.mul(o,t.div(i,c)),{x:r,y:o}}}function gn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=Ft(r,2,{...e,DST:e.DST,...o}),f=t.fromAffine(n(s[0])),i=t.fromAffine(n(s[1])),c=f.add(i).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){const s=Ft(r,1,{...e,DST:e.encodeDST,...o}),f=t.fromAffine(n(s[0])).clearCofactor();return f.assertValidity(),f}}}class he extends ne{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Se(n);const r=re(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?n.create().update(r).digest():r);for(let f=0;f<s.length;f++)s[f]^=54;this.iHash.update(s),this.oHash=n.create();for(let f=0;f<s.length;f++)s[f]^=106;this.oHash.update(s),s.fill(0)}update(n){return mt(this),this.iHash.update(n),this}digestInto(n){mt(this),Ae(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:s,blockLen:f,outputLen:i}=this;return n=n,n.finished=o,n.destroyed=s,n.blockLen=f,n.outputLen=i,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ge=(t,n,e)=>new he(t,n).update(e).digest();ge.create=(t,n)=>new he(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function wn(t){return{hash:t,hmac:(n,...e)=>ge(t,n,Ie(...e)),randomBytes:oe}}function bn(t,n){const e=r=>on({...t,...wn(r)});return Object.freeze({...e(n),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _t=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Et=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),we=BigInt(1),Bt=BigInt(2),te=(t,n)=>(t+n/Bt)/n;function be(t){const n=_t,e=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),f=BigInt(23),i=BigInt(44),c=BigInt(88),a=t*t*t%n,h=a*a*t%n,u=D(h,e,n)*h%n,v=D(u,e,n)*h%n,E=D(v,Bt,n)*a%n,y=D(E,o,n)*E%n,l=D(y,s,n)*y%n,g=D(l,i,n)*l%n,d=D(g,c,n)*g%n,b=D(d,i,n)*l%n,p=D(b,e,n)*h%n,S=D(p,f,n)*y%n,I=D(S,r,n)*a%n,x=D(I,Bt,n);if(!ot.eql(ot.sqr(x),t))throw new Error("Cannot find square root");return x}const ot=We(_t,void 0,void 0,{sqrt:be}),Ot=bn({a:BigInt(0),b:BigInt(7),Fp:ot,n:Et,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Et,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-we*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,f=BigInt("0x100000000000000000000000000000000"),i=te(s*t,n),c=te(-r*t,n);let a=R(t-i*e-c*o,n),h=R(-i*r-c*s,n);const u=a>f,v=h>f;if(u&&(a=n-a),v&&(h=n-h),a>f||h>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:a,k2neg:v,k2:h}}}},pt),qt=BigInt(0),ye=t=>typeof t=="bigint"&&qt<t&&t<_t,yn=t=>typeof t=="bigint"&&qt<t&&t<Et,ee={};function vt(t,...n){let e=ee[t];if(e===void 0){const r=pt(Uint8Array.from(t,o=>o.charCodeAt(0)));e=K(r,r),ee[t]=e}return pt(K(e,...n))}const Kt=t=>t.toRawBytes(!0).slice(1),$t=t=>rt(t,32),Lt=t=>R(t,_t),yt=t=>R(t,Et),Dt=Ot.ProjectivePoint,mn=(t,n,e)=>Dt.BASE.multiplyAndAddUnsafe(t,n,e);function kt(t){let n=Ot.utils.normPrivateKeyToScalar(t),e=Dt.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:yt(-n),bytes:Kt(e)}}function me(t){if(!ye(t))throw new Error("bad x: need 0 < x < p");const n=Lt(t*t),e=Lt(n*t+BigInt(7));let r=be(e);r%Bt!==qt&&(r=Lt(-r));const o=new Dt(t,r,we);return o.assertValidity(),o}function pe(...t){return yt(Z(vt("BIP0340/challenge",...t)))}function pn(t){return kt(t).bytes}function xn(t,n,e=oe(32)){const r=$("message",t),{bytes:o,scalar:s}=kt(n),f=$("auxRand",e,32),i=$t(s^Z(vt("BIP0340/aux",f))),c=vt("BIP0340/nonce",i,o,r),a=yt(Z(c));if(a===qt)throw new Error("sign failed: k is zero");const{bytes:h,scalar:u}=kt(a),v=pe(h,o,r),E=new Uint8Array(64);if(E.set(h,0),E.set($t(yt(u+v*s)),32),!xe(E,r,o))throw new Error("sign: Invalid signature produced");return E}function xe(t,n,e){const r=$("signature",t,64),o=$("message",n),s=$("publicKey",e,32);try{const f=me(Z(s)),i=Z(r.subarray(0,32));if(!ye(i))return!1;const c=Z(r.subarray(32,64));if(!yn(c))return!1;const a=pe($t(i),Kt(f),o),h=mn(f,c,yt(-a));return!(!h||!h.hasEvenY()||h.toAffine().x!==i)}catch{return!1}}const An={getPublicKey:pn,sign:xn,verify:xe,utils:{randomPrivateKey:Ot.utils.randomPrivateKey,lift_x:me,pointToBytes:Kt,numberToBytesBE:rt,bytesToNumberBE:Z,taggedHash:vt,mod:R}},En=hn(ot,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))),Bn=cn(ot,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ot.create(BigInt("-11"))}),Ee=gn(Ot.ProjectivePoint,t=>{const{x:n,y:e}=Bn(ot.create(t[0]));return En(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ot.ORDER,m:1,k:128,expand:"xmd",hash:pt}),In=Ee.hashToCurve,_n=Ee.encodeToCurve;export{_n as encodeToCurve,In as hashToCurve,An as schnorr,Ot as secp256k1};
